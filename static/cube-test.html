<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rubik's Cube Test</title>
    <link rel="stylesheet" href="cube.css">
    <!-- Three.js library for 3D rendering -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <h1>Rubik's Cube Test</h1>
    
    <div id="container">
        <div id="cubeCanvas"></div>
        
        <div class="controls">
            <div class="face-controls">
                <div class="face-label">Front Face (White)</div>
                <button onclick="rotateFace(0, true)">Rotate Clockwise</button>
                <button onclick="rotateFace(0, false)">Rotate Counter-Clockwise</button>
            </div>
            
            <div class="face-controls">
                <div class="face-label">Back Face (Yellow)</div>
                <button onclick="rotateFace(1, true)">Rotate Clockwise</button>
                <button onclick="rotateFace(1, false)">Rotate Counter-Clockwise</button>
            </div>
            
            <div class="face-controls">
                <div class="face-label">Up Face (Blue)</div>
                <button onclick="rotateFace(2, true)">Rotate Clockwise</button>
                <button onclick="rotateFace(2, false)">Rotate Counter-Clockwise</button>
            </div>
            
            <div class="face-controls">
                <div class="face-label">Down Face (Green)</div>
                <button onclick="rotateFace(3, true)">Rotate Clockwise</button>
                <button onclick="rotateFace(3, false)">Rotate Counter-Clockwise</button>
            </div>
            
            <div class="face-controls">
                <div class="face-label">Left Face (Red)</div>
                <button onclick="rotateFace(4, true)">Rotate Clockwise</button>
                <button onclick="rotateFace(4, false)">Rotate Counter-Clockwise</button>
            </div>
            
            <div class="face-controls">
                <div class="face-label">Right Face (Orange)</div>
                <button onclick="rotateFace(5, true)">Rotate Clockwise</button>
                <button onclick="rotateFace(5, false)">Rotate Counter-Clockwise</button>
            </div>
            
            <button class="reset" onclick="resetCube()">Reset Cube</button>
            <button onclick="logState()">Log State</button>
        </div>
    </div>
    
    <script>
        // ThreeJS variables
        let scene, camera, renderer, controls;
        let cubeGroup;
        const cubeSize = 1;
        const gap = 0.05;
        let isAnimating = false; // Track if an animation is in progress
        let cubeState; // Store the cube state locally
        
        // Color mapping (HTML color names to hex values)
        const colorMap = {
            'white': 0xFFFFFF,
            'yellow': 0xFFFF00,
            'blue': 0x0000FF,
            'green': 0x00FF00,
            'red': 0xFF0000,
            'orange': 0xFFA500,
            'black': 0x000000
        };
        
        // Tracking rotated cubes for debugging
        let lastRotationInfo = {
            face: -1,
            clockwise: false,
            cubes: []
        };
        
        // Initialize with a solved cube state
        function initCubeState() {
            // Create a 6×3×3 array representing the cube state
            cubeState = Array(6).fill().map(() => 
                Array(3).fill().map(() => Array(3).fill(''))
            );
            
            // Fill each face with its color
            const colors = ['white', 'yellow', 'blue', 'green', 'red', 'orange'];
            for (let face = 0; face < 6; face++) {
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        cubeState[face][i][j] = colors[face];
                    }
                }
            }
            
            // Log the initial state
            console.log("Cube state initialized");
        }
        
        // Setup ThreeJS scene
        function initThree() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, 600 / 500, 0.1, 1000);
            camera.position.set(4, 4, 4);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(600, 500);
            document.getElementById('cubeCanvas').appendChild(renderer.domElement);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(10, 20, 30);
            scene.add(directionalLight);
            
            // Create cube group
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);
            
            // Start animation loop
            animate();
            
            console.log("Three.js scene initialized");
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Create a cube based on the state
        function createCube() {
            // Clear existing cube
            while(cubeGroup.children.length > 0) {
                cubeGroup.remove(cubeGroup.children[0]);
            }
            
            // Create small cubes
            for(let x = -1; x <= 1; x++) {
                for(let y = -1; y <= 1; y++) {
                    for(let z = -1; z <= 1; z++) {
                        // Skip center cube
                        if(x === 0 && y === 0 && z === 0) continue;
                        
                        createCubePiece(x, y, z);
                    }
                }
            }
            console.log("Cube created with", cubeGroup.children.length, "cubies");
        }
        
        // Create a single cube piece
        function createCubePiece(x, y, z) {
            const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            const materials = [];
            
            // Create array of 6 materials for each side of the cube
            for (let i = 0; i < 6; i++) {
                materials.push(new THREE.MeshStandardMaterial({ 
                    color: 0x333333,  // Default dark gray
                    side: THREE.DoubleSide
                }));
            }
            
            // Right face (x = 1) - Orange (Face 5)
            if(x === 1) {
                materials[0].color.setHex(colorMap[cubeState[5][y+1][z+1]]);
            }
            
            // Left face (x = -1) - Red (Face 4)
            if(x === -1) {
                materials[1].color.setHex(colorMap[cubeState[4][y+1][2-z]]);
            }
            
            // Top face (y = 1) - Blue (Face 2)
            if(y === 1) {
                materials[2].color.setHex(colorMap[cubeState[2][2-z][x+1]]);
            }
            
            // Bottom face (y = -1) - Green (Face 3)
            if(y === -1) {
                materials[3].color.setHex(colorMap[cubeState[3][z+1][x+1]]);
            }
            
            // Front face (z = 1) - White (Face 0)
            if(z === 1) {
                materials[4].color.setHex(colorMap[cubeState[0][y+1][x+1]]);
            }
            
            // Back face (z = -1) - Yellow (Face 1)
            if(z === -1) {
                materials[5].color.setHex(colorMap[cubeState[1][y+1][2-x]]);
            }
            
            const cube = new THREE.Mesh(geometry, materials);
            cube.position.set(
                x * (cubeSize + gap),
                y * (cubeSize + gap),
                z * (cubeSize + gap)
            );
            
            // Add position as custom properties for animation selection
            cube.userData = { posX: x, posY: y, posZ: z };
            
            // Add black lines around edges to make cubies stand out
            const edgeGeometry = new THREE.EdgesGeometry(geometry);
            const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 });
            const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
            cube.add(edges);
            
            cubeGroup.add(cube);
            
            // Add debug labels to corner cubies
            if ((Math.abs(x) === 1) && (Math.abs(y) === 1) && (Math.abs(z) === 1)) {
                const label = `${y > 0 ? 'U' : 'D'}${x > 0 ? 'R' : 'L'}${z > 0 ? 'F' : 'B'}`;
                addDebugLabel(cube, label);
            }
        }
        
        // Add debug label to cubes
        function addDebugLabel(cube, text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 128;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 128, 128);
            ctx.fillStyle = '#000000';
            ctx.font = 'Bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, 64, 76);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            
            // Position label on the corner
            const x = cube.userData.posX * 0.7;
            const y = cube.userData.posY * 0.7;
            const z = cube.userData.posZ * 0.7;
            sprite.position.set(x, y, z);
            
            sprite.scale.set(0.4, 0.4, 1);
            cube.add(sprite);
        }
        
        // Reset the cube
        function resetCube() {
            if (isAnimating) return; // Prevent action during animation
            initCubeState();
            createCube();
        }
        
        // Log the current cube state for debugging
        function logState() {
            console.clear();
            console.log("Current Cube State:");
            
            const faceNames = ["Front (White)", "Back (Yellow)", "Top (Blue)", 
                              "Bottom (Green)", "Left (Red)", "Right (Orange)"];
            
            for (let face = 0; face < 6; face++) {
                console.log(`\nFace ${face} - ${faceNames[face]}:`);
                for (let i = 0; i < 3; i++) {
                    console.log(cubeState[face][i]);
                }
            }
            
            if (lastRotationInfo.face !== -1) {
                console.log(`\nLast rotation: Face ${lastRotationInfo.face} ${lastRotationInfo.clockwise ? 'clockwise' : 'counter-clockwise'}`);
                console.log("Rotated cubes:", lastRotationInfo.cubes.length);
            }
        }
        
        // Rotate a specific face
        function rotateFace(face, clockwise) {
            if (isAnimating) return; // Prevent multiple rotations during animation
            isAnimating = true;
            
            console.log(`Rotating face ${face} ${clockwise ? 'clockwise' : 'counter-clockwise'}`);
            
            // Create a rotation group
            const rotationGroup = new THREE.Group();
            scene.add(rotationGroup);
            
            // Store info for debugging
            lastRotationInfo = {
                face: face,
                clockwise: clockwise,
                cubes: []
            };
            
            // Find cubes to rotate
            cubeGroup.children.forEach(cube => {
                if (shouldRotateWithFace(cube, face)) {
                    lastRotationInfo.cubes.push({
                        posX: cube.userData.posX,
                        posY: cube.userData.posY,
                        posZ: cube.userData.posZ
                    });
                    
                    cubeGroup.remove(cube);
                    rotationGroup.add(cube);
                }
            });
            
            console.log(`Rotating ${lastRotationInfo.cubes.length} cubies`);
            
            // Get rotation axis
            const rotationAxis = getRotationAxis(face);
            const rotationAngle = clockwise ? Math.PI / 2 : -Math.PI / 2;
            const rotationSpeed = 0.05;
            
            // Animate rotation
            let angle = 0;
            const rotateAnimation = () => {
                if (Math.abs(angle) < Math.abs(rotationAngle)) {
                    const step = rotationSpeed * Math.sign(rotationAngle);
                    angle += step;
                    rotationGroup.rotateOnAxis(rotationAxis, step);
                    requestAnimationFrame(rotateAnimation);
                } else {
                    // Animation complete
                    console.log("Animation completed");
                    
                    // Update cube positions after rotation
                    rotationGroup.updateMatrixWorld(true);
                    
                    const rotatedCubes = [];
                    while (rotationGroup.children.length > 0) {
                        const cube = rotationGroup.children[0];
                        rotationGroup.remove(cube);
                        
                        // Calculate new world position
                        const worldPos = new THREE.Vector3();
                        cube.getWorldPosition(worldPos);
                        
                        // Convert to grid position (rounded to nearest integer)
                        const gridPos = {
                            x: Math.round(worldPos.x / (cubeSize + gap)),
                            y: Math.round(worldPos.y / (cubeSize + gap)),
                            z: Math.round(worldPos.z / (cubeSize + gap))
                        };
                        
                        // Update cube userData with new position
                        cube.userData.posX = gridPos.x;
                        cube.userData.posY = gridPos.y;
                        cube.userData.posZ = gridPos.z;
                        
                        rotatedCubes.push(cube);
                    }
                    
                    // Add rotated cubes back to main group
                    rotatedCubes.forEach(cube => cubeGroup.add(cube));
                    
                    // Remove rotation group
                    scene.remove(rotationGroup);
                    
                    // Update the cube state
                    updateCubeState(face, clockwise);
                    
                    // Rebuild the 3D cube with the new state
                    createCube();
                    
                    isAnimating = false;
                }
            };
            
            // Start animation
            rotateAnimation();
        }
        
        // Determine if a cube should rotate with the face
        function shouldRotateWithFace(cube, face) {
            const { posX, posY, posZ } = cube.userData;
            
            switch(face) {
                case 0: // Front (White)
                    return posZ === 1;
                case 1: // Back (Yellow)
                    return posZ === -1;
                case 2: // Top (Blue)
                    return posY === 1;
                case 3: // Bottom (Green)
                    return posY === -1;
                case 4: // Left (Red)
                    return posX === -1;
                case 5: // Right (Orange)
                    return posX === 1;
                default:
                    return false;
            }
        }
        
        // Get rotation axis
        function getRotationAxis(face) {
            switch(face) {
                case 0: return new THREE.Vector3(0, 0, 1);  // Front
                case 1: return new THREE.Vector3(0, 0, -1); // Back
                case 2: return new THREE.Vector3(0, 1, 0);  // Top
                case 3: return new THREE.Vector3(0, -1, 0); // Bottom
                case 4: return new THREE.Vector3(-1, 0, 0); // Left
                case 5: return new THREE.Vector3(1, 0, 0);  // Right
                default: return new THREE.Vector3(0, 1, 0);
            }
        }
        
        // Update the cube state after a rotation
        function updateCubeState(face, clockwise) {
            // Get a copy of the current state
            const newState = JSON.parse(JSON.stringify(cubeState));
            
            // Rotate the face itself
            rotateFaceState(newState, face, clockwise);
            
            // Update the adjacent edges
            updateAdjacentEdges(newState, face, clockwise);
            
            // Apply the new state
            cubeState = newState;
        }
        
        // Rotate a face in the state model
        function rotateFaceState(state, face, clockwise) {
            // Create a copy of the face
            const oldFace = JSON.parse(JSON.stringify(state[face]));
            
            if (clockwise) {
                // Rotate 90° clockwise
                state[face][0][0] = oldFace[2][0];
                state[face][0][1] = oldFace[1][0];
                state[face][0][2] = oldFace[0][0];
                state[face][1][0] = oldFace[2][1];
                state[face][1][2] = oldFace[0][1];
                state[face][2][0] = oldFace[2][2];
                state[face][2][1] = oldFace[1][2];
                state[face][2][2] = oldFace[0][2];
            } else {
                // Rotate 90° counter-clockwise
                state[face][0][0] = oldFace[0][2];
                state[face][0][1] = oldFace[1][2];
                state[face][0][2] = oldFace[2][2];
                state[face][1][0] = oldFace[0][1];
                state[face][1][2] = oldFace[2][1];
                state[face][2][0] = oldFace[0][0];
                state[face][2][1] = oldFace[1][0];
                state[face][2][2] = oldFace[2][0];
            }
        }
        
        // Update edges of adjacent faces after rotation
        function updateAdjacentEdges(state, face, clockwise) {
            let temp;
            
            switch(face) {
                case 0: // Front (affects Top, Right, Bottom, Left)
                    // Save the values we'll overwrite
                    temp = [...state[2][2]]; // Bottom row of Top
                    
                    if (clockwise) {
                        // Top → Right → Bottom → Left → Top
                        // Left edge to Top
                        state[2][2][0] = state[4][2][2];
                        state[2][2][1] = state[4][1][2];
                        state[2][2][2] = state[4][0][2];
                        
                        // Bottom edge to Left
                        state[4][0][2] = state[3][0][2];
                        state[4][1][2] = state[3][0][1];
                        state[4][2][2] = state[3][0][0];
                        
                        // Right edge to Bottom
                        state[3][0][0] = state[5][2][0];
                        state[3][0][1] = state[5][1][0];
                        state[3][0][2] = state[5][0][0];
                        
                        // Top edge to Right
                        state[5][0][0] = temp[2];
                        state[5][1][0] = temp[1];
                        state[5][2][0] = temp[0];
                    } else {
                        // Top → Left → Bottom → Right → Top
                        // Right edge to Top
                        state[2][2][0] = state[5][2][0];
                        state[2][2][1] = state[5][1][0];
                        state[2][2][2] = state[5][0][0];
                        
                        // Top edge to Left
                        state[4][0][2] = temp[2];
                        state[4][1][2] = temp[1];
                        state[4][2][2] = temp[0];
                        
                        // Left edge to Bottom
                        state[3][0][0] = state[4][2][2];
                        state[3][0][1] = state[4][1][2];
                        state[3][0][2] = state[4][0][2];
                        
                        // Bottom edge to Right
                        state[5][0][0] = state[3][0][2];
                        state[5][1][0] = state[3][0][1];
                        state[5][2][0] = state[3][0][0];
                    }
                    break;
                    
                case 1: // Back face (affects Top, Left, Bottom, Right)
                    // Save the values we'll overwrite
                    temp = [...state[2][0]]; // Top row of Top
                    
                    if (clockwise) {
                        // Top → Left → Bottom → Right → Top
                        // Right edge to Top
                        state[2][0][0] = state[5][2][2];
                        state[2][0][1] = state[5][1][2];
                        state[2][0][2] = state[5][0][2];
                        
                        // Top edge to Left
                        state[4][0][0] = temp[2];
                        state[4][1][0] = temp[1];
                        state[4][2][0] = temp[0];
                        
                        // Left edge to Bottom
                        state[3][2][0] = state[4][2][0];
                        state[3][2][1] = state[4][1][0];
                        state[3][2][2] = state[4][0][0];
                        
                        // Bottom edge to Right
                        state[5][0][2] = state[3][2][2];
                        state[5][1][2] = state[3][2][1];
                        state[5][2][2] = state[3][2][0];
                    } else {
                        // Top → Right → Bottom → Left → Top
                        // Left edge to Top
                        state[2][0][0] = state[4][2][0];
                        state[2][0][1] = state[4][1][0];
                        state[2][0][2] = state[4][0][0];
                        
                        // Bottom edge to Left
                        state[4][0][0] = state[3][2][2];
                        state[4][1][0] = state[3][2][1];
                        state[4][2][0] = state[3][2][0];
                        
                        // Right edge to Bottom
                        state[3][2][0] = state[5][2][2];
                        state[3][2][1] = state[5][1][2];
                        state[3][2][2] = state[5][0][2];
                        
                        // Top edge to Right
                        state[5][0][2] = temp[2];
                        state[5][1][2] = temp[1];
                        state[5][2][2] = temp[0];
                    }
                    break;
                    
                case 2: // Top face (affects Front, Right, Back, Left)
                    // Save the values we'll overwrite
                    temp = [...state[0][0]]; // Top row of Front
                    
                    if (clockwise) {
                        // Front → Right → Back → Left → Front
                        // Left edge to Front
                        state[0][0][0] = state[4][0][0];
                        state[0][0][1] = state[4][0][1];
                        state[0][0][2] = state[4][0][2];
                        
                        // Back edge to Left
                        state[4][0][0] = state[1][0][2];
                        state[4][0][1] = state[1][0][1];
                        state[4][0][2] = state[1][0][0];
                        
                        // Right edge to Back
                        state[1][0][0] = state[5][0][2];
                        state[1][0][1] = state[5][0][1];
                        state[1][0][2] = state[5][0][0];
                        
                        // Front edge to Right
                        state[5][0][0] = temp[0];
                        state[5][0][1] = temp[1];
                        state[5][0][2] = temp[2];
                    } else {
                        // Front → Left → Back → Right → Front
                        // Right edge to Front
                        state[0][0][0] = state[5][0][0];
                        state[0][0][1] = state[5][0][1];
                        state[0][0][2] = state[5][0][2];
                        
                        // Front edge to Left
                        state[4][0][0] = temp[0];
                        state[4][0][1] = temp[1];
                        state[4][0][2] = temp[2];
                        
                        // Left edge to Back
                        state[1][0][0] = state[4][0][2];
                        state[1][0][1] = state[4][0][1];
                        state[1][0][2] = state[4][0][0];
                        
                        // Back edge to Right
                        state[5][0][0] = state[1][0][2];
                        state[5][0][1] = state[1][0][1];
                        state[5][0][2] = state[1][0][0];
                    }
                    break;
                    
                case 3: // Bottom face (affects Front, Left, Back, Right)
                    // Save the values we'll overwrite
                    temp = [...state[0][2]]; // Bottom row of Front
                    
                    if (clockwise) {
                        // Front → Left → Back → Right → Front
                        // Right edge to Front
                        state[0][2][0] = state[5][2][0];
                        state[0][2][1] = state[5][2][1];
                        state[0][2][2] = state[5][2][2];
                        
                        // Front edge to Left
                        state[4][2][0] = temp[0];
                        state[4][2][1] = temp[1];
                        state[4][2][2] = temp[2];
                        
                        // Left edge to Back
                        state[1][2][0] = state[4][2][2];
                        state[1][2][1] = state[4][2][1];
                        state[1][2][2] = state[4][2][0];
                        
                        // Back edge to Right
                        state[5][2][0] = state[1][2][2];
                        state[5][2][1] = state[1][2][1];
                        state[5][2][2] = state[1][2][0];
                    } else {
                        // Front → Right → Back → Left → Front
                        // Left edge to Front
                        state[0][2][0] = state[4][2][0];
                        state[0][2][1] = state[4][2][1];
                        state[0][2][2] = state[4][2][2];
                        
                        // Back edge to Left
                        state[4][2][0] = state[1][2][2];
                        state[4][2][1] = state[1][2][1];
                        state[4][2][2] = state[1][2][0];
                        
                        // Right edge to Back
                        state[1][2][0] = state[5][2][2];
                        state[1][2][1] = state[5][2][1];
                        state[1][2][2] = state[5][2][0];
                        
                        // Front edge to Right
                        state[5][2][0] = temp[0];
                        state[5][2][1] = temp[1];
                        state[5][2][2] = temp[2];
                    }
                    break;
                    
                case 4: // Left face (affects Top, Front, Bottom, Back)
                    // Save the values we'll overwrite
                    temp = [state[2][0][0], state[2][1][0], state[2][2][0]]; // Left column of Top
                    
                    if (clockwise) {
                        // Top → Back → Bottom → Front → Top
                        // Front column to Top
                        state[2][0][0] = state[0][2][0];
                        state[2][1][0] = state[0][1][0];
                        state[2][2][0] = state[0][0][0];
                        
                        // Bottom column to Front
                        state[0][0][0] = state[3][0][0];
                        state[0][1][0] = state[3][1][0];
                        state[0][2][0] = state[3][2][0];
                        
                        // Back column to Bottom
                        state[3][0][0] = state[1][2][2];
                        state[3][1][0] = state[1][1][2];
                        state[3][2][0] = state[1][0][2];
                        
                        // Top column to Back
                        state[1][0][2] = temp[0];
                        state[1][1][2] = temp[1];
                        state[1][2][2] = temp[2];
                    } else {
                        // Top → Front → Bottom → Back → Top
                        // Back column to Top
                        state[2][0][0] = state[1][0][2];
                        state[2][1][0] = state[1][1][2];
                        state[2][2][0] = state[1][2][2];
                        
                        // Top column to Front
                        state[0][0][0] = temp[2];
                        state[0][1][0] = temp[1];
                        state[0][2][0] = temp[0];
                        
                        // Front column to Bottom
                        state[3][0][0] = state[0][0][0];
                        state[3][1][0] = state[0][1][0];
                        state[3][2][0] = state[0][2][0];
                        
                        // Bottom column to Back
                        state[1][0][2] = state[3][2][0];
                        state[1][1][2] = state[3][1][0];
                        state[1][2][2] = state[3][0][0];
                    }
                    break;
                    
                case 5: // Right face (affects Top, Front, Bottom, Back)
                    // Save the values we'll overwrite
                    temp = [state[2][0][2], state[2][1][2], state[2][2][2]]; // Right column of Top
                    
                    if (clockwise) {
                        // Top → Front → Bottom → Back → Top
                        // Back column to Top
                        state[2][0][2] = state[1][0][0];
                        state[2][1][2] = state[1][1][0];
                        state[2][2][2] = state[1][2][0];
                        
                        // Top column to Front
                        state[0][0][2] = temp[2];
                        state[0][1][2] = temp[1];
                        state[0][2][2] = temp[0];
                        
                        // Front column to Bottom
                        state[3][0][2] = state[0][0][2];
                        state[3][1][2] = state[0][1][2];
                        state[3][2][2] = state[0][2][2];
                        
                        // Bottom column to Back
                        state[1][0][0] = state[3][2][2];
                        state[1][1][0] = state[3][1][2];
                        state[1][2][0] = state[3][0][2];
                    } else {
                        // Top → Back → Bottom → Front → Top
                        // Front column to Top
                        state[2][0][2] = state[0][2][2];
                        state[2][1][2] = state[0][1][2];
                        state[2][2][2] = state[0][0][2];
                        
                        // Bottom column to Front
                        state[0][0][2] = state[3][0][2];
                        state[0][1][2] = state[3][1][2];
                        state[0][2][2] = state[3][2][2];
                        
                        // Back column to Bottom
                        state[3][0][2] = state[1][2][0];
                        state[3][1][2] = state[1][1][0];
                        state[3][2][2] = state[1][0][0];
                        
                        // Top column to Back
                        state[1][0][0] = temp[0];
                        state[1][1][0] = temp[1];
                        state[1][2][0] = temp[2];
                    }
                    break;
            }
        }
        
        // Initialize on page load
        window.onload = function() {
            initCubeState();
            initThree();
            createCube();
        }
    </script>
</body>
</html>